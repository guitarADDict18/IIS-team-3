/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package encryption;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Andrei
 */
public class transpositionPanel extends javax.swing.JPanel {

    /**
     * Creates new form transpositionPanel
     */
    public transpositionPanel() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        transBtnGrp = new javax.swing.ButtonGroup();
        jScrollPane1 = new javax.swing.JScrollPane();
        plainTextArea = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        cipherTextArea = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        keyTextField = new javax.swing.JTextField();
        pcButton = new javax.swing.JRadioButton();
        cpButton = new javax.swing.JRadioButton();
        solveButton = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        chkMediation = new javax.swing.JCheckBox();
        jScrollPane4 = new javax.swing.JScrollPane();
        visTable = new javax.swing.JTable();

        setLayout(new java.awt.GridBagLayout());

        plainTextArea.setColumns(20);
        plainTextArea.setFont(new java.awt.Font("Monospaced", 1, 14)); // NOI18N
        plainTextArea.setRows(5);
        jScrollPane1.setViewportView(plainTextArea);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 15, 10, 15);
        add(jScrollPane1, gridBagConstraints);

        cipherTextArea.setColumns(20);
        cipherTextArea.setFont(new java.awt.Font("Monospaced", 1, 14)); // NOI18N
        cipherTextArea.setRows(5);
        cipherTextArea.setEnabled(false);
        jScrollPane2.setViewportView(cipherTextArea);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 10, 15);
        add(jScrollPane2, gridBagConstraints);

        jLabel1.setText("Plaintext");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(0, 19, 0, 4);
        add(jLabel1, gridBagConstraints);

        jLabel2.setText("Ciphertext");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        add(jLabel2, gridBagConstraints);

        jLabel3.setText("Visualization Table");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.insets = new java.awt.Insets(10, 0, 0, 0);
        add(jLabel3, gridBagConstraints);

        keyTextField.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 100);
        add(keyTextField, gridBagConstraints);

        transBtnGrp.add(pcButton);
        pcButton.setSelected(true);
        pcButton.setText("P -> C");
        pcButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                pcButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        add(pcButton, gridBagConstraints);

        transBtnGrp.add(cpButton);
        cpButton.setText("C -> P");
        cpButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cpButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        add(cpButton, gridBagConstraints);

        solveButton.setText("Solve");
        solveButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                solveButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        add(solveButton, gridBagConstraints);

        jLabel4.setText("Key:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
        add(jLabel4, gridBagConstraints);

        chkMediation.setSelected(true);
        chkMediation.setText("Complete Mediation");
        chkMediation.setName("chkMediation"); // NOI18N
        add(chkMediation, new java.awt.GridBagConstraints());

        visTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane4.setViewportView(visTable);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.gridwidth = 3;
        add(jScrollPane4, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents

    private void solveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_solveButtonActionPerformed
        if (cpButton.isSelected()) {
            decrypt();
        } else {
            encrypt();
        }
    }//GEN-LAST:event_solveButtonActionPerformed

    private void pcButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pcButtonActionPerformed
        plainTextArea.setEnabled(true);
        cipherTextArea.setText("");
        cipherTextArea.setEnabled(false);
    }//GEN-LAST:event_pcButtonActionPerformed

    private void cpButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cpButtonActionPerformed
        plainTextArea.setText("");
        plainTextArea.setEnabled(false);
        cipherTextArea.setEnabled(true);
    }//GEN-LAST:event_cpButtonActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox chkMediation;
    private javax.swing.JTextArea cipherTextArea;
    private javax.swing.JRadioButton cpButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTextField keyTextField;
    private javax.swing.JRadioButton pcButton;
    private javax.swing.JTextArea plainTextArea;
    private javax.swing.JButton solveButton;
    private javax.swing.ButtonGroup transBtnGrp;
    private javax.swing.JTable visTable;
    // End of variables declaration//GEN-END:variables

    private void encrypt() {
        if (mediate()) {
            if (plainTextArea.getText().length() != 0) {
                //Text area isn't empty so we can perform the encryption
                String key = keyTextField.getText();
                int keyLen = keyTextField.getText().length();
                //  String plainText = plainTextArea.getText().toLowerCase();
                String plainText = plainTextArea.getText().replaceAll("\\s", ""); // replaces space with blank
                plainText = plainText.toLowerCase();
                plainText = plainText.replaceAll("[^a-z]", ""); //ptxt is english alphabet only
                String cipherText = "";
                int plainLen = plainText.length();

                int row_dimension = (int) Math.ceil((double) plainLen / (double) keyLen);

                // [rows][columns]
                Character[][] trans_matrix = new Character[row_dimension][keyLen];

                // need to write the word to this matrix row by row
                int wordcounter = 0;
                boolean go = true;
                for (int row = 0; row < row_dimension; row++) {
                    for (int column = 0; column < keyLen; column++) {
                        char current = plainText.charAt(wordcounter);
                        trans_matrix[row][column] = new Character(current);
                        ++wordcounter;
                        if (wordcounter == plainLen) {
                            go = false;
                            break;
                        }
                    }
                    if (!go) {
                        break;
                    }
                }

                updateVisTable(keyLen, row_dimension, key, plainText);

                //need to grab the cipher text from the table column by 
                // column in the order specified by the keyword
                StringBuilder cipher = new StringBuilder();

                char[] key_c = key.toCharArray();

                for (int i = 1; i < key.length(); i++) { // insertion sort
                    char element1 = key_c[i];
                    int j = i;
                    while ((j > 0) && (key_c[j - 1] > element1)) {
                        key_c[j] = key_c[j - 1];
                        j--;
                    }
                    key_c[j] = element1;
                }

                for (int i = 0; i < key.length(); i++) {
                    int working_column = location(key_c, key.charAt(i));
                    for (int row = 0; row < row_dimension; row++) {
                        if (trans_matrix[row][working_column] == null) {
                            continue;
                        }
                        char column_elem = trans_matrix[row][working_column];
                        cipher.append(column_elem);
                    }
                }
                cipherText = cipher.toString();
                cipherTextArea.setText(cipherText);
            }
        }
    }

    private void decrypt() {
        if (mediate()) {
            if (cipherTextArea.getText().length() != 0) {
                //Text area isn't empty so we can perform the encryption
                String key = keyTextField.getText().toLowerCase().replaceAll("\\s", "");
                int keyLen = key.length();

                String cipherText = cipherTextArea.getText().toLowerCase();
                cipherText = cipherText.replaceAll("\\s", "");
                int cipherLen = cipherText.length();

                String plainText = "";

                int row_dimension = (int) Math.ceil((double) cipherLen / (double) keyLen);
                // [rows][columns]
                Character[][] trans_matrix = new Character[row_dimension][keyLen];

                char[] key_c = key.toCharArray();
                // sort the keyword
                for (int i = 1; i < key.length(); i++) {
                    char element1 = key_c[i];
                    int j = i;
                    while ((j > 0) && (key_c[j - 1] > element1)) {
                        key_c[j] = key_c[j - 1];
                        j--;
                    }
                    key_c[j] = element1;
                }

                int wordcounter = 0;
                int full_rows = cipherLen % keyLen;
                boolean go = true;
                for (int key_i = 0; key_i < key.length(); key_i++) {
                    int current_column = location(key_c, key.charAt(key_i));
                    for (int row = 0; row < row_dimension; row++) {
                        if (current_column < full_rows || full_rows == 0) {
                            trans_matrix[row][current_column] =
                                    new Character(cipherText.charAt(wordcounter));
                            wordcounter++;
                        } else {
                            if (row == row_dimension - 1) {
                                continue;
                            } else {
                                trans_matrix[row][current_column] =
                                        new Character(cipherText.charAt(wordcounter));
                                wordcounter++;
                            }
                        }
                    }
                }
                
                // reads of matrix and puts it in plain text as solution
                StringBuilder plain = new StringBuilder();
                for (int row = 0; row < row_dimension; row++) {
                    for (int column = 0; column < key.length(); column++) {
                        if (trans_matrix[row][column] == null) {
                            continue;
                        }
                        plain.append(trans_matrix[row][column]);
                    }
                }

                plainText = plain.toString();
                plainTextArea.setText(plainText);
                updateVisTable(keyLen, row_dimension, key, plainText);
            }
        }
    }
    
    private void updateVisTable(int keyLen, int row_dimension, String key, String plainText){
        //copy pasta-ed
        //customize col and row of visTable
        String[] columnNames = new String[keyLen];
        for (int i = 0; i < keyLen; i++) {
            columnNames[i] = key.substring(i, i
                    + 1);
        }
        Object[][] data = new Object[row_dimension][keyLen];
        for (int i = 0; i < plainText.length(); ++i) {
            data[i / keyLen][i % keyLen] = plainText.substring(i, i + 1);
        }
        visTable.setModel(new DefaultTableModel(data, columnNames));
    }
    
    private int location(char[] key, char letter) {
        for (int i = 0; i < key.length; i++) {
            if (key[i] == letter) {
                return i;
            }
        }
        return -1;
    }

    private boolean mediate() {  // error checking, called only if checkbox is checked
        boolean isGood = true;
        if (chkMediation.isSelected()) {
            StringBuilder sb = new StringBuilder();
            sb.append("Please fix the following errors: \n\n");

            // checking lengths
            int trueLength = cipherTextArea.getText().replaceAll("\\s", "").length();
            if (keyTextField.getText().length() > trueLength
                    && cipherTextArea.isEnabled()) {
                sb.append("* The key cannot be longer then the cipher text \n");
                isGood = false;
            }

            trueLength = plainTextArea.getText().replaceAll("\\s", "").length();
            if (keyTextField.getText().length() > trueLength
                    && plainTextArea.isEnabled()) {
                sb.append("* The key cannot be longer then the plain text \n");
                isGood = false;
            }

            // need to check for repeat characters in key
            String adjKey = keyTextField.getText().toLowerCase();
            adjKey = adjKey.replaceAll("[^a-z]", ""); //takes lower case and takes
            // out non alphabetical chars
            boolean keepgoing = true;
            for (int i = 0; i < adjKey.length(); i++) {
                for (int j = i+1; j < adjKey.length(); j++) {
                    char current = adjKey.charAt(i);
                    char compare = adjKey.charAt(j);
                    if (current == compare) {
                        isGood = false;
                        keepgoing = false;
                        sb.append("* The key cannot contain repeat characters \n");
                        break;
                    }
                }
                if (!keepgoing) {
                    break;
                }
            }

            if (!isGood) {
                String message = sb.toString();
                JOptionPane op = new JOptionPane();
                op.showMessageDialog(null, message);
            }
        }
        return isGood;
    }
}
